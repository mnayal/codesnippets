<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="9a73bc7b-fe13-4a50-b7ab-738e0adf548f" name="Default Changelist" comment="" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="CodeStyleSettingsInfer">
    <option name="done" value="true" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="ProjectCodeStyleSettingsMigration">
    <option name="version" value="1" />
  </component>
  <component name="ProjectId" id="1cFmnZBmQAyZjyl3Gp8GPJIZbkk" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showExcludedFiles" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
    <property name="cursive.last.file.extension.C\:/Users/mnayal/tempProj/codegladp1/src" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="settings.editor.selected.configurable" value="Clojure.IDE" />
  </component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="C:\Users\mnayal\tempProj\codegladp1\src\codegladp1" />
    </key>
  </component>
  <component name="ReplState" timestamp="1596121004384">{:repl-history {:ide [], :local [{:command &quot;(defn -main [&amp; args]\n  (println \&quot;Hello, World!\&quot;))&quot;, :offset 49, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (println \&quot;Hello, World!\&quot;)\n  (let [temp (read-line)]\n    temp))&quot;, :offset 85, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [no-ing (read-line)\n        #_no-ing #_(Integer/parseInt (read-line))]\n    no-ing))&quot;, :offset 111, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [no-ing (Integer/parseInt (read-line))\n        #_no-ing #_(Integer/parseInt (read-line))]\n    no-ing))&quot;, :offset 130, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [no-ing (Integer/parseInt (read-line))\n        q-pp (map #(Integer/parseInt %) (str/split #\&quot; \&quot; (read-line)))]\n    q-pp))&quot;, :offset 148, :ns &quot;codegladp1.core&quot;} {:command &quot;(use 'Clojure.string :as s)&quot;, :offset 27, :ns &quot;codegladp1.core&quot;} {:command &quot;(use '[Clojure.string :as s])&quot;, :offset 29, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [no-ing (Integer/parseInt (read-line))\n        q-pp (map #(Integer/parseInt %) (s/split #\&quot; \&quot; (read-line)))]\n    q-pp))&quot;, :offset 146, :ns &quot;codegladp1.core&quot;} {:command &quot;(s/split #\&quot; \&quot; \&quot;1 2 3\&quot;)&quot;, :offset 22, :ns &quot;codegladp1.core&quot;} {:command &quot;(s/split #' ' \&quot;1 2 3\&quot;)&quot;, :offset 22, :ns &quot;codegladp1.core&quot;} {:command &quot;(s/split \&quot;1 2 3\&quot; #\&quot; \&quot;)&quot;, :offset 22, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [no-ing (Integer/parseInt (read-line))\n        q-pp (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))]\n    q-pp))&quot;, :offset 146, :ns &quot;codegladp1.core&quot;} {:command &quot;(s/split (read-line) #\&quot; \&quot;)&quot;, :offset 26, :ns &quot;codegladp1.core&quot;} {:command &quot;(map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))&quot;, :offset 54, :ns &quot;codegladp1.core&quot;} {:command &quot;(Math/abs (/ 4 2))&quot;, :offset 18, :ns &quot;codegladp1.core&quot;} {:command &quot;(Math/floor (/ 4 3))&quot;, :offset 20, :ns &quot;codegladp1.core&quot;} {:command &quot;(Math/abs (/ 4 3))&quot;, :offset 18, :ns &quot;codegladp1.core&quot;} {:command &quot;(/ 4 3)&quot;, :offset 7, :ns &quot;codegladp1.core&quot;} {:command &quot;(&gt; (/ 4 3) 1)&quot;, :offset 13, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [no-ing (Integer/parseInt (read-line))\n        q-required (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))\n        q-have (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))\n        new-map (map #(/ %1 %2) q-have q-required)]\n    (min new-map)))&quot;, :offset 282, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [no-ing (Integer/parseInt (read-line))\n        q-required (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))\n        q-have (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))\n        new-map (map #(/ %1 %2) q-have q-required)]\n    (apply min new-map)))&quot;, :offset 288, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [no-ing (Integer/parseInt (read-line))\n        q-required (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))\n        q-have (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))\n        new-map (map #(quot %1 %2) q-have q-required)]\n    (apply min new-map)))&quot;, :offset 291, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [no-ing (Integer/parseInt (read-line))\n        q-required (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))\n        q-have (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))\n        new-map (map #(quot %1 %2) q-have q-required)]\n    (print (apply min new-map))))&quot;, :offset 299, :ns &quot;codegladp1.core&quot;} {:command &quot;(repeat 10)&quot;, :offset 11, :ns &quot;codegladp1.core&quot;} {:command &quot;(repeat 10 \&quot;Hello\&quot;)&quot;, :offset 19, :ns &quot;codegladp1.core&quot;} {:command &quot;(sort [1 4 7 3])&quot;, :offset 16, :ns &quot;codegladp1.core&quot;} {:command &quot;(map &gt; [1 2 3] [2 3 4])&quot;, :offset 23, :ns &quot;codegladp1.core&quot;} {:command &quot;(map &gt; [1 2 3] [2 3 0])&quot;, :offset 23, :ns &quot;codegladp1.core&quot;} {:command &quot;(map &gt; [1 2 3] [1 3 0])&quot;, :offset 23, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [tests-no (Integer/parseInt (read-line))]\n    (repeat tests-no\n            (let [team-nos (Integer/parseInt (read-line))\n                  G-power (sort (map #(Long/parseLong %) (s/split (read-line) #\&quot; \&quot;)))\n                  opp-power (sort (map #(Long/parseLong %) (s/split (read-line) #\&quot; \&quot;)))]\n              (print (count (filter identity (map &gt; G-power opp-power))))))))&quot;, :offset 401, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [tests-no (Integer/parseInt (read-line))]\n    (repeat tests-no\n            (let [team-nos (Integer/parseInt (read-line))\n                  G-power (sort (map #(Long/parseLong %) (s/split (read-line) #\&quot; \&quot;)))\n                  opp-power (sort (map #(Long/parseLong %) (s/split (read-line) #\&quot; \&quot;)))]\n              (println G-power)\n              (println opp-power)\n              #_(print (count (filter identity (map &gt; G-power opp-power))))))))&quot;, :offset 469, :ns &quot;codegladp1.core&quot;} {:command &quot;(map-indexed identity [1 2 3])&quot;, :offset 30, :ns &quot;codegladp1.core&quot;} {:command &quot;(nth [1 2 3] 1)&quot;, :offset 15, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [tests-no (Integer/parseInt (read-line))]\n    (repeat tests-no\n            (let [team-nos (Integer/parseInt (read-line))\n                  G-power (sort (map #(Long/parseLong %) (s/split (read-line) #\&quot; \&quot;)))\n                  opp-power (sort (map #(Long/parseLong %) (s/split (read-line) #\&quot; \&quot;)))]\n              (wins G-power opp-power 0 0 0 team-nos)))))&quot;, :offset 381, :ns &quot;codegladp1.core&quot;} {:command &quot;(repeat 10 (println \&quot;hello\&quot;))&quot;, :offset 29, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn wins [G-power opp-power count posG posOpp total]\n  (if (and (&lt; posG total) (&lt; posOpp total))\n    (if (&lt; (nth opp-power posOpp) (nth G-power posG))\n      (recur G-power opp-power (inc count) (inc posG) (inc posOpp) total)\n      (recur G-power opp-power count (inc posG) posOpp total))\n    (println count)))&quot;, :offset 311, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [tests-no (Integer/parseInt (read-line))]\n    (dotimes [n tests-no]\n      (let [team-nos (Integer/parseInt (read-line))\n            G-power (sort (map #(Long/parseLong %) (s/split (read-line) #\&quot; \&quot;)))\n            opp-power (sort (map #(Long/parseLong %) (s/split (read-line) #\&quot; \&quot;)))]\n        (wins G-power opp-power 0 0 0 team-nos)))))&quot;, :offset 362, :ns &quot;codegladp1.core&quot;} {:command &quot;(-main)&quot;, :offset 7, :ns &quot;codegladp1.core&quot;} {:command &quot;(mapv identity '(1 2 3))&quot;, :offset 24, :ns &quot;codegladp1.core&quot;} {:command &quot;(sort &gt; (mapv identity '(1 2 3)))&quot;, :offset 33, :ns &quot;codegladp1.core&quot;} {:command &quot;(sort &lt; (mapv identity '(1 2 3)))&quot;, :offset 33, :ns &quot;codegladp1.core&quot;} {:command &quot;(vec (sort &lt; (mapv identity '(1 2 3))))&quot;, :offset 39, :ns &quot;codegladp1.core&quot;} {:command &quot;((vec (sort &lt; (mapv identity '(1 2 3)))) 0)&quot;, :offset 43, :ns &quot;codegladp1.core&quot;} {:command &quot;((vec (sort &lt; (mapv identity '(1 2 3)))) 1)&quot;, :offset 43, :ns &quot;codegladp1.core&quot;} {:command &quot;(defn wins [G-power opp-power count posG posOpp total]\n  (if (and (&lt; posG total) (&lt; posOpp total))\n    (if (&lt; (opp-power posOpp) (G-power posG))\n      (recur G-power opp-power (inc count) (inc posG) (inc posOpp) total)\n      (recur G-power opp-power count (inc posG) posOpp total))\n    (println count)))&quot;, :offset 303, :ns &quot;codegladp1.core&quot;} {:command &quot;(range 1 5 2)&quot;, :offset 13, :ns &quot;codegladp1.core&quot;} {:command &quot;(type (* 2 4))&quot;, :offset 14, :ns &quot;codegladp1.core&quot;} {:command &quot;(type 1)&quot;, :offset 8, :ns &quot;codegladp1.core&quot;} {:command &quot;1&quot;, :offset 1, :ns &quot;user&quot;} {:command &quot;(defn get-all-deps\n  ([deps-data]\n   (get-all-deps #{} deps-data))\n  ([final-set [k v]]\n   (if (contains? final-set k)\n     (do\n       (println \&quot;contains: \&quot; final-set)\n       final-set)\n     (if (nil? v)\n       (do\n         (println \&quot;nil: \&quot; final-set k)\n         (conj final-set k))\n       (do\n         (println \&quot;call again: \&quot; final-set v)\n         (reduce get-all-deps (conj final-set k) v))))))&quot;, :offset 396, :ns &quot;codegladp1.he&quot;} {:command &quot;(get-all-deps deps-data)&quot;, :offset 24, :ns &quot;codegladp1.he&quot;}], :remote [{:command &quot;(some #(= 1 %) [3 4 5 1])&quot;, :offset 25, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(take-nth 2 [1 2 3 4 5])&quot;, :offset 24, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(let [coll [1 2 3 4 5]\n      new-coll (if (odd? (coll 0)) coll (rest coll))]\n (take-nth 2 new-coll))&quot;, :offset 100, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(let [coll [2 3 4 5]\n      new-coll (if (odd? (coll 0)) coll (rest coll))]\n (take-nth 2 new-coll))&quot;, :offset 98, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(let [coll [2 3 4 5 6]\n      new-coll (if (odd? (coll 0)) coll (rest coll))]\n (take-nth 2 new-coll))&quot;, :offset 100, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(let [coll [2 3 4 5 6 7]\n      new-coll (if (odd? (coll 0)) coll (rest coll))]\n (take-nth 2 new-coll))&quot;, :offset 102, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(range 0 8)&quot;, :offset 11, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(range 1 8)&quot;, :offset 11, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn test [start end]\n  (let [new-start (if (odd? start) start (inc start))\n        new-coll (range new-start (inc end))]\n    (take-nth 2 new-coll)))&quot;, :offset 150, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(test 3 9)&quot;, :offset 10, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(count [1 2])&quot;, :offset 13, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(conj [1 2 3] 4)&quot;, :offset 16, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;({\&quot;[\&quot; \&quot;]\&quot;} \&quot;[\&quot;)&quot;, :offset 15, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(cons [1 2 3] 4)&quot;, :offset 16, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(cons 4 [1 2 3])&quot;, :offset 16, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn braces [values]\n  (let [zero-based-length (dec (count values))]\n    (loop [start true\n           stack []\n           curr-pos-stack -1\n           val-pos 0]\n      (if (and (= curr-pos-stack -1) (&lt; val-pos zero-based-length))\n        \&quot;YES\&quot;\n        (if (and (not= val-pos 0) (= curr-pos-stack -1) (&lt; val-pos zero-based-length))\n          \&quot;NO\&quot;\n          (if start\n            (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))\n            (if (= (stack curr-pos-stack) (braces-map (values val-pos)))\n              (recur false (butlast stack) (dec curr-pos-stack) (inc val-pos))\n              (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))))))))\n  )&quot;, :offset 712, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(let [inp (read-line)]\n  (print inp))&quot;, :offset 37, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(let [inp (read-line)]\n  (print (vec inp)))&quot;, :offset 43, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(let [inp (read-line)]\n  (print (vec inp))\n  (= (inp 0) (inp 1)))&quot;, :offset 65, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(let [inp (vec (read-line))]\n  (= (inp 0) (inp 1)))&quot;, :offset 51, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;aaabbccc&quot;, :offset 8, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(let [inp (vec (read-line))]\n  (= (inp 3) (inp 4)))&quot;, :offset 51, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(def braces-map\n  {\&quot;[\&quot; \&quot;]\&quot;\n   \&quot;{\&quot; \&quot;}\&quot;\n   \&quot;(\&quot; \&quot;)\&quot;})&quot;, :offset 50, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack [values]\n  (let [zero-based-length (dec (count values))]\n    (loop [start true\n           stack []\n           curr-pos-stack -1\n           val-pos 0]\n      (if (and (= curr-pos-stack -1) (&lt; val-pos zero-based-length))\n        \&quot;YES\&quot;\n        (if (and (not= val-pos 0) (= curr-pos-stack -1) (&lt; val-pos zero-based-length))\n          \&quot;NO\&quot;\n          (if start\n            (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))\n            (if (= (stack curr-pos-stack) (braces-map (values val-pos)))\n              (recur false (butlast stack) (dec curr-pos-stack) (inc val-pos))\n              (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos)))))))))&quot;, :offset 719, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn braces [values]\n  (map #(go-through-stack (vec %)) values)\n  )&quot;, :offset 68, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack [values]\n  (let [zero-based-length (dec (count values))]\n    (loop [start true\n           stack []\n           curr-pos-stack -1\n           val-pos 0]\n      (if (and (= curr-pos-stack -1) (= val-pos zero-based-length))\n        \&quot;YES\&quot;\n        (if (and (not= val-pos 0) (= curr-pos-stack -1) (&lt; val-pos zero-based-length))\n          \&quot;NO\&quot;\n          (if start\n            (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))\n            (if (= (stack curr-pos-stack) (braces-map (values val-pos)))\n              (recur false (butlast stack) (dec curr-pos-stack) (inc val-pos))\n              (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos)))))))))&quot;, :offset 719, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack [values]\n  (let [zero-based-length (dec (count values))]\n    (print zero-based-length)\n    (loop [start true\n           stack []\n           curr-pos-stack -1\n           val-pos 0]\n      (if (and (= curr-pos-stack -1) (= val-pos zero-based-length))\n        \&quot;YES\&quot;\n        (if (and (not= val-pos 0) (= curr-pos-stack -1) (&lt; val-pos zero-based-length))\n          \&quot;NO\&quot;\n          (if start\n            (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))\n            (if (= (stack curr-pos-stack) (braces-map (values val-pos)))\n              (do (println curr-pos-stack val-pos)\n                  (recur false (butlast stack) (dec curr-pos-stack) (inc val-pos)))\n              (do\n                (println curr-pos-stack val-pos)\n                (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))))))))))&quot;, :offset 875, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack [values]\n  (let [zero-based-length (dec (count values))]\n    (println zero-based-length)\n    (loop [start true\n           stack []\n           curr-pos-stack -1\n           val-pos 0]\n      (if (and (= curr-pos-stack -1) (= val-pos zero-based-length))\n        \&quot;YES\&quot;\n        (if (and (not= val-pos 0) (= curr-pos-stack -1) (&lt; val-pos zero-based-length))\n          \&quot;NO\&quot;\n          (if start\n            (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))\n            (if (= (stack curr-pos-stack) (braces-map (values val-pos)))\n              (do (println curr-pos-stack val-pos)\n                  (recur false (butlast stack) (dec curr-pos-stack) (inc val-pos)))\n              (do\n                (println curr-pos-stack val-pos)\n                (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))))))))))&quot;, :offset 877, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack [values]\n  (let [zero-based-length (dec (count values))]\n    (println zero-based-length)\n    (loop [start true\n           stack []\n           curr-pos-stack -1\n           val-pos 0]\n      (if (and (= curr-pos-stack -1) (= val-pos zero-based-length))\n        \&quot;YES\&quot;\n        (if (and (not= val-pos 0) (= curr-pos-stack -1) (= val-pos zero-based-length))\n          \&quot;NO\&quot;\n          (if start\n            (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))\n            (if (= (stack curr-pos-stack) (braces-map (values val-pos)))\n              (do (println curr-pos-stack val-pos)\n                  (recur false (butlast stack) (dec curr-pos-stack) (inc val-pos)))\n              (do\n                (println curr-pos-stack val-pos)\n                (recur false (conj stack (values val-pos)) (inc curr-pos-stack) (inc val-pos))))))))))&quot;, :offset 877, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(cons 1 [1 2 3])&quot;, :offset 16, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(cons 1 [2 3])&quot;, :offset 14, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(cons 1 [2 3 4])&quot;, :offset 16, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack [values]\n  (let [output (seq (reduce \n                      (fn [stack item]\n                        (println stack item)\n                          (if (empty? stack)\n                            (cons item stack)\n                            (if (= (stack 0) (braces-map item))\n                              (rest stack)\n                              (cons item stack))))\n                        []\n                        values))]\n        (if output \&quot;YES\&quot; \&quot;NO\&quot;)))&quot;, :offset 487, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(last [1 2 3])&quot;, :offset 14, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack [values]\n  (let [output (seq (reduce \n                      (fn [stack item]\n                        (println stack item)\n                          (if (empty? stack)\n                            (conj stack item)\n                            (if (= (last stack) (braces-map item))\n                              (butlast stack)\n                              (conj stack item))))\n                        []\n                        values))]\n        (if output \&quot;YES\&quot; \&quot;NO\&quot;)))&quot;, :offset 493, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(go-through-stack [1 2 2 1])&quot;, :offset 28, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(go-through-stack [1 2 2 1 3])&quot;, :offset 30, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(char-array {}[]())&quot;, :offset 19, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(char-array (read-line))&quot;, :offset 24, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(seq (chars (char-array (read-line))))&quot;, :offset 38, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(vec (char-array (read-line)))&quot;, :offset 30, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(butlast [1 2 3])&quot;, :offset 17, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack [values]\n  (let [output (seq (reduce\n                      (fn [stack item]\n                        (println stack item)\n                          (if (empty? stack)\n                            (conj stack item)\n                            (let [last (last stack)\n                                  current (braces-map item)]\n                              (println \&quot;--\&quot; last current \&quot;--\&quot;)\n                              (if (= last current)\n                               (vec (butlast stack))\n                               (conj stack item)))))\n                        []\n                        values))]\n        (if output \&quot;NO\&quot; \&quot;YES\&quot;)))&quot;, :offset 661, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(int-array (read-line))&quot;, :offset 23, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(int-array (char-array (read-line)))&quot;, :offset 36, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(Character/digit \&quot;1\&quot; 10)&quot;, :offset 24, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(Character/digit \\1 10)&quot;, :offset 23, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(Character/digit \\0)&quot;, :offset 20, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(Character/digit \\0 10)&quot;, :offset 23, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(map #(Character/digit % 10) (read-line))&quot;, :offset 41, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(mapv #(println %1 %2) '(1 2 3 4))&quot;, :offset 34, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(mapv #(println %1 %2) [1 2 3 4])&quot;, :offset 33, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(map-indexed #(println %1 %2) [1 2 3 4])&quot;, :offset 40, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(map-indexed #(println %1 %2) '(1 2 3 4))&quot;, :offset 41, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack []\n  (let [colls (map #(Character/digit % 10) (read-line))]\n    (filter identity (map-indexed #(if (= %2 1) % nil) colls))))&quot;, :offset 147, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(union #{1 2} #{3})&quot;, :offset 19, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(ns codegladp1.hacker-rank\n  (:require [clojure.string :as s]\n            [clojure.set :as cs]))&quot;, :offset 96, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(cs/union #{1 2} #{3})&quot;, :offset 22, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(cs/intersection #{1 2} #{3})&quot;, :offset 29, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(cs/intersection #{1 2} #{3 1})&quot;, :offset 31, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack []\n  (let [num-coll (map #(Character/digit % 10) (read-line))\n        current-relations (into (filter identity (map-indexed #(if (= %2 1) % nil) num-coll))\n                                #{})]\n    current-relations\n    ))&quot;, :offset 245, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn go-through-stack []\n  (let [num-coll (map #(Character/digit % 10) (read-line))\n        current-relations (into #{} \n                                (filter identity (map-indexed #(if (= %2 1) % nil) num-coll)))]\n    current-relations\n    ))&quot;, :offset 246, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(go-through-stack)&quot;, :offset 18, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(keep-indexed #(if (= %2 1) %1 nil) [1 0 0 1 1 0 1])&quot;, :offset 52, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(empty? #{})&quot;, :offset 12, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(some (fn [[k v]] (if (empty? (cs/intersection v #{2})) nil k)) {0 #{1} 1 #{2}})&quot;, :offset 80, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(some (fn [[k v]] (if (empty? (cs/intersection v #{1})) nil k)) {0 #{1} 1 #{2}})&quot;, :offset 80, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(some (fn [[k v]] (if (empty? (cs/intersection v #{3})) nil k)) {0 #{1} 1 #{2}})&quot;, :offset 80, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(update {0 #{1} 1 #{2}} 1 cs/union #{3})&quot;, :offset 40, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(update {0 #{1} 1 #{2}} 0 cs/union #{3})&quot;, :offset 40, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn groups-count [values]\n  (let [mapped (map-indexed (fn [index value]\n                              [index (map #(Character/digit % 10) value)])\n                            values)]\n    (count\n      (reduce\n        (fn [final-groups [index relations]]\n          (let [relations-set (into #{} (keep-indexed #(if (= %2 1) % nil) relations))\n                key-found (some (fn [[k v]]\n                                  (if (empty? (cs/intersection v relations-set))\n                                    nil\n                                    k))\n                                final-groups)]\n            (if key-found\n              (update final-groups key-found cs/union relations-set)\n              (assoc final-groups index relations-set))))\n        {}\n        mapped))))&quot;, :offset 777, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(def fptr (get (System/getenv) \&quot;OUTPUT_PATH\&quot;))&quot;, :offset 46, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(spit fptr \&quot;\\n\&quot; :append true)&quot;, :offset 29, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(map read-line (range 3))&quot;, :offset 25, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(map #(do (read-line)) (range 3))&quot;, :offset 33, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(for [x (range 3)]\n  (read-line)\n  )&quot;, :offset 36, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(for [_ (range 3)] (read-line))&quot;, :offset 31, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn groups-count []\n  (let [count (Integer/parseInt (read-line))\n        values (for [_ (range count)] (read-line))\n        mapped (map-indexed (fn [index value]\n                              [index (map #(Character/digit % 10) value)])\n                            values)\n        relations-set-fn (fn [v] (into #{} (keep-indexed #(if (= %2 1) % nil) v)))\n        find-group-fn (fn [groups curr-group]\n                        (some (fn [[k v]]\n                               (if (empty? (cs/intersection v curr-group))\n                                 nil\n                                 k))\n                              groups))]\n    (count\n      (reduce\n        (fn [final-groups [index line]]\n          (let [relations-set (relations-set-fn line)\n                group-key (find-group-fn final-groups relations-set)]\n            (if group-key\n              (update final-groups group-key cs/union relations-set)\n              (assoc final-groups index relations-set))))\n        {}\n        mapped))))&quot;, :offset 1006, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(Integer/parseInt (read-line))&quot;, :offset 30, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn groups-count []\n  (let [count (Integer/parseInt (read-line))\n        values (for [_ (range count)] (read-line))\n        _ (print values)\n        mapped (map-indexed (fn [index value]\n                              [index (map #(Character/digit % 10) value)])\n                            values)\n        relations-set-fn (fn [v] (into #{} (keep-indexed #(if (= %2 1) % nil) v)))\n        find-group-fn (fn [groups curr-group]\n                        (some (fn [[k v]]\n                               (if (empty? (cs/intersection v curr-group))\n                                 nil\n                                 k))\n                              groups))]\n    (count\n      (reduce\n        (fn [final-groups [index line]]\n          (let [relations-set (relations-set-fn line)\n                group-key (find-group-fn final-groups relations-set)]\n            (if group-key\n              (update final-groups group-key cs/union relations-set)\n              (assoc final-groups index relations-set))))\n        {}\n        mapped))))&quot;, :offset 1031, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn groups-count []\n  (let [count (Integer/parseInt (read-line))\n        values (for [_ (range count)] (read-line))\n        _ (print values)\n        mapped (map-indexed (fn [index value]\n                              [index (map #(Character/digit % 10) value)])\n                            values)\n        _ (print mapped)\n        relations-set-fn (fn [v] (into #{} (keep-indexed #(if (= %2 1) % nil) v)))\n        find-group-fn (fn [groups curr-group]\n                        (some (fn [[k v]]\n                               (if (empty? (cs/intersection v curr-group))\n                                 nil\n                                 k))\n                              groups))]\n    (count\n      (reduce\n        (fn [final-groups [index line]]\n          (let [relations-set (relations-set-fn line)\n                group-key (find-group-fn final-groups relations-set)]\n            (if group-key\n              (update final-groups group-key cs/union relations-set)\n              (assoc final-groups index relations-set))))\n        {}\n        mapped))))&quot;, :offset 1056, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(defn groups-count []\n  (let [count (Integer/parseInt (read-line))\n        values (for [_ (range count)] (read-line))\n        mapped (map-indexed (fn [index value]\n                              [index (map #(Character/digit % 10) value)])\n                            values)\n        relations-set-fn (fn [v] (into #{} (keep-indexed #(if (= %2 1) % nil) v)))\n        find-group-fn (fn [groups curr-group]\n                        (some (fn [[k v]]\n                               (if (empty? (cs/intersection v curr-group))\n                                 nil\n                                 k))\n                              groups))]\n    (count\n      (reduce\n        (fn [final-groups [index line]]\n          (println final-groups index line)\n          (let [relations-set (relations-set-fn line)\n                group-key (find-group-fn final-groups relations-set)]\n            (if group-key\n              (update final-groups group-key cs/union relations-set)\n              (assoc final-groups index relations-set))))\n        {}\n        mapped))))&quot;, :offset 1050, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;6&quot;, :offset 1, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(groups-count)&quot;, :offset 14, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(require '(clojure.set :as cs))&quot;, :offset 31, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(require '(clojure [set :as cs]))&quot;, :offset 33, :ns &quot;codegladp1.hacker-rank&quot;} {:command &quot;(+ 1 1)&quot;, :offset 6, :ns &quot;user&quot;} {:command &quot;(defn -main [&amp; args]\n  (let [[P D] (map #(Integer/parseInt %) (s/split (read-line) #\&quot; \&quot;))]\n    (print P D)))&quot;, :offset 108, :ns &quot;codegladp1.core&quot;} {:command &quot;1&quot;, :offset 1, :ns &quot;codegladp1.core&quot;} {:command &quot;(-main)&quot;, :offset 7, :ns &quot;codegladp1.core&quot;} {:command &quot;(Long 1)&quot;, :offset 8, :ns &quot;codegladp1.core&quot;} {:command &quot;(println (Long 1))&quot;, :offset 18, :ns &quot;codegladp1.core&quot;} {:command &quot;(range 1 5 1)&quot;, :offset 13, :ns &quot;codegladp1.core&quot;} {:command &quot;(range 1 5 2)&quot;, :offset 13, :ns &quot;codegladp1.core&quot;} {:command &quot;(long 1)&quot;, :offset 8, :ns &quot;codegladp1.core&quot;} {:command &quot;(* (long 2) (long 4))&quot;, :offset 21, :ns &quot;codegladp1.core&quot;} {:command &quot;(type (* (long 2) (long 4)))&quot;, :offset 28, :ns &quot;codegladp1.core&quot;} {:command &quot;(type (* (long 2) 4))&quot;, :offset 21, :ns &quot;codegladp1.core&quot;} {:command &quot;(type (* 2 4))&quot;, :offset 14, :ns &quot;codegladp1.core&quot;} {:command &quot;(type 1)&quot;, :offset 8, :ns &quot;codegladp1.core&quot;}]}}</component>
  <component name="RunManager" selected="Clojure REPL.local">
    <configuration name="Unnamed" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false" nameIsGenerated="true">
      <module name="codegladp1" />
      <setting name="host" value="localhost" />
      <setting name="port" value="58631" />
      <setting name="replType" value="NREPL" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="local" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="codegladp1" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure REPL.local" />
      <item itemvalue="Clojure REPL.Unnamed" />
    </list>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="9a73bc7b-fe13-4a50-b7ab-738e0adf548f" name="Default Changelist" comment="" />
      <created>1590132883014</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1590132883014</updated>
    </task>
    <servers />
  </component>
  <component name="WindowStateProjectService">
    <state x="137" y="18" key="#com.intellij.execution.impl.EditConfigurationsDialog" timestamp="1596029565619">
      <screen x="0" y="0" width="1366" height="728" />
    </state>
    <state x="137" y="18" key="#com.intellij.execution.impl.EditConfigurationsDialog/0.0.1366.728@0.0.1366.728" timestamp="1596029565619" />
    <state x="531" y="252" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog" timestamp="1590132907701">
      <screen x="0" y="0" width="1366" height="728" />
    </state>
    <state x="531" y="252" key="#com.intellij.ide.util.projectWizard.JdkChooserPanel.MyDialog/0.0.1366.728@0.0.1366.728" timestamp="1590132907701" />
    <state x="463" y="118" key="FileChooserDialogImpl" timestamp="1594278201334">
      <screen x="0" y="0" width="1366" height="728" />
    </state>
    <state x="463" y="118" key="FileChooserDialogImpl/0.0.1366.728@0.0.1366.728" timestamp="1594278201334" />
    <state x="263" y="106" key="IDE.errors.dialog" timestamp="1596028921608">
      <screen x="0" y="0" width="1366" height="728" />
    </state>
    <state x="263" y="106" key="IDE.errors.dialog/0.0.1366.728@0.0.1366.728" timestamp="1596028921608" />
    <state x="184" y="6" key="SettingsEditor" timestamp="1596028983977">
      <screen x="0" y="0" width="1366" height="728" />
    </state>
    <state x="184" y="6" key="SettingsEditor/0.0.1366.728@0.0.1366.728" timestamp="1596028983977" />
    <state x="92" y="92" width="1182" height="544" key="com.intellij.history.integration.ui.views.FileHistoryDialog" timestamp="1590147385721">
      <screen x="0" y="0" width="1366" height="728" />
    </state>
    <state x="92" y="92" width="1182" height="544" key="com.intellij.history.integration.ui.views.FileHistoryDialog/0.0.1366.728@0.0.1366.728" timestamp="1590147385721" />
    <state x="260" y="99" width="846" height="603" key="com.intellij.xdebugger.impl.breakpoints.ui.BreakpointsDialogFactory$2" timestamp="1596028859974">
      <screen x="0" y="0" width="1366" height="728" />
    </state>
    <state x="260" y="99" width="846" height="603" key="com.intellij.xdebugger.impl.breakpoints.ui.BreakpointsDialogFactory$2/0.0.1366.728@0.0.1366.728" timestamp="1596028859974" />
    <state x="346" y="49" width="672" height="678" key="search.everywhere.popup" timestamp="1596028821180">
      <screen x="0" y="0" width="1366" height="728" />
    </state>
    <state x="346" y="49" width="672" height="678" key="search.everywhere.popup/0.0.1366.728@0.0.1366.728" timestamp="1596028821180" />
  </component>
</project>